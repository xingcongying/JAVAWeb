
一、JDBC概述
在java中，数据库存取技术可分为如下几类：
1、JDBC直接访问数据库
2、JD0(JAVA Data Object)技术
3、第三方O/R工具，如hibernate、mybatis
JDBC是java访问数据库的基石，hibernate、mybatis只是更好的封装了JDBC。

JDBC：Java DataBase Connectivity
JDBC本质：SUN公司定义的一套操作所有关系型数据库的规则(接口)。各个数据库厂商去实现这个接口，提供数据库驱动jar包。我们可以使用这套接口进行编程，真正执行的代码是驱动jar包中的实现类

二、快速入门

1.导入驱动jar包
2.注册驱动
3.获取数据库连接对象 Connection
4.定义sql语句
5.获取执行sql语句的对象 Statement
6.执行sql，接收返回结果
7.处理结果
8.释放资源，最后开启的资源要先释放
释放的资源有ResultSet(仅查询时使用)、Statement、Connection

三、数据库连接中使用到的类和接口
DriverManager类：驱动管理对象
Connection接口：数据库连接对象
Statement接口：用于执行静态 SQL 语句并返回它所生成结果的对象 
ResultSet接口：接收Statement接口返回的结果集对象
PreparedStatement接口：是Statement的子接口，执行预编译SQL语句的对象(解决注入问题)

1) DriverManager类
驱动管理对象

功能：
注册驱动：告诉程序该使用哪一个数据库驱动jar包；

2. 获取数据库连接：建立到给定数据库 URL 的连接
static Connection getConnection(String url, String user, String password)
参数： url：指定连接的路径
其中协议与子协议是固定写法
子名称是 ip地址(域名)：端口号/数据库名称
注意：如果连接的是本机的默认端口号是3306的mysql服务器，url可简写：
jdbc:mysql:///数据库名称，即省略ip地址(域名)：端口号
user：数据库用户名
Password: 数据库登陆密码

(2) Connection接口
数据库连接对象
功能：

1、获取执行sql语句的对象
a. Statement createStatement( ) 创建一个 Statement 对象来将 SQL 语句发送到数据库
b. PreparedStatement prepareStatement(String sql)
创建一个 PreparedStatement 对象来将参数化的 SQL 语句发送到数据库
2、管理事务：
开启事务：void setAutoCommit(boolean autoCommit) 参数设置为false开启事务
提交事务：void commit()
回滚事务：void rollback()

(3) Statement接口
用于执行静态 SQL 语句并返回它所生成结果的对象

1、int executeUpdate(String sql)
执行除了select之外的其余sql语句，即不返回任何内容的sql语句，返回值是受影响的行数， 可以通过返回的int值判断sql语句是否执行成功(>0则成功，反之失败)，不使用ResultSet
2、ResultSet executeQuery(String sql)
执行给定的select语句，该语句返回单个 ResultSet 对象
3、boolean execute(String sql)
执行给定的 SQL 语句，该语句可能返回多个结果 (了解，不常用)


(4) ResultSet接口
结果集对象(可认为是查询出的一张表)
有一个游标指向第一行的上一行，需要调用方法使游标下移，再调用方法获取指向行中某一列的值，注意：无法获取整行的值，只可以获取行中某一列的值

使用JDBC工具类：JDBCUtils
目的：简化书写，将每次使用JDBC都要重复写的代码抽取出来，放在静态方法中，方便调用
分析：
1.抽取注册驱动的代码
2.抽取一个方法获取连接对象
3.抽取一个方法释放资源

代码演示4：使用JDBCUtils对Order表进行查询，结果放入集合中，并返回集合
1.创建一个Order类
public class Order {
    //一个类代表一张表，类中的属性代表一列，一个对象代表一行(ORM编程思想)
    private int order_id;
    private String order_name;
    private Date order_date; //util下的Date
    //定义所有属性的getter/setter方法
    public int getOrder_id() {
        return order_id;
    }
    public void setOrder_id(int order_id) {
        this.order_id = order_id;
    }
    public String getOrder_name() {
        return order_name;
    }
    public void setOrder_name(String order_name) {
        this.order_name = order_name;
    }
    public Date getOrder_date() {
        return order_date;
    }
    public void setOrder_date(Date order_date) {
        this.order_date = order_date;
    }
    @Override
    public String toString() {
        return "Order{" +
                "order_id=" + order_id +
                ", order_name='" + order_name + '\'' +
                ", order_date=" + order_date +
                '}';
    }
}

2.在src下创建一个配置文件jdbc.properties
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/test
user=root
password=root //更改数据库或驱动只需更改配置文件即可，其余无需更改，体现可扩展性

3.创建工具类JDBCUtils
public class JDBCUtils {
    //1.注册驱动
    private static String url;
    private static String user;
    private static String password;
    private static String password;
    private static String driver;
    //静态代码块
    static {
        try {
            //读取配置文件(都写在try中，一旦有一处出现异常其余没必要再执行)
            Properties properties = new Properties();
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            InputStream resourceAsStream =
                    classLoader.getResourceAsStream("jdbc.properties");
            properties.load(resourceAsStream); //抛出异常
            url = properties.getProperty("url");
            user = properties.getProperty("user");
            password = properties.getProperty("password");
            driver = properties.getProperty("driver");
            //注册驱动
            Class.forName(driver);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    //2.获取连接(抛出异常)
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(url,user,password);
    }
    /*可直接类名.getConnection注册驱动，静态方法调动类加载，从而调动静态代码块*/
    //3.关闭资源
    //可能需要关闭ResultSet，也可能不需要，故需重载
    public static void close(Statement stmt, Connection conn) {
        if (stmt!=null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (conn!=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    public static void close(ResultSet rs, Statement stmt, Connection conn) {
        if (rs!=null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (stmt!=null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (conn!=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}
        if (stmt!=null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (conn!=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

4.编写测试类进行查询
public class MyTest {
    public List<Order> search() {
        List<Order> list = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            connection = JDBCUtils.getConnection();
            statement = connection.createStatement();
            String sql = "select * from orders";
            resultSet = statement.executeQuery(sql);
            //创建Order类对象、集合
            Order order = null;
            list = new ArrayList<>();
            //循环
            while (resultSet.next()) {
                int order_id = resultSet.getInt("order_id");
                String order_name = resultSet.getString("order_name");
                Date order_date = resultSet.getDate("order_date");
	        //sql包的Date是Util包Date的子类，多态                
	        //每次遍历一行需创建一个对象，保存一行的所有数据
                order = new Order();
                order.setOrder_date(order_date);/*使用set赋值，而不使用构造器赋值，因为可
                order.setOrder_id(order_id);       能用户查询的列数并没有合适个数的构造器*/
                order.setOrder_name(order_name);
                //将order装入集合
                list.add(order);
                //继续下一次遍历
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JDBCUtils.close(resultSet,statement,connection);
        }
        return list;
    }
    //执行
    public static void main(String[] args) {
        List<Order> listResult = new MyTest().search();
        System.out.println(listResult);
        System.out.println(listResult.size());
    }
}
        return list;
    }
    //执行
    public static void main(String[] args) {
        List<Order> listResult = new MyTest().search();
        System.out.println(listResult);
        System.out.println(listResult.size());
    }
}

(5) PreparedStatement接口
  //获取连接，执行sql语句
        try {
            connection = JDBCUtils.getConnection();
            String sql = "select * from user where name = ? and password = ?";
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1,userName);
            preparedStatement.setString(2,passWord);
            resultSet = preparedStatement.executeQuery();
            return resultSet.next();
            
五、结果集的元数据

调用结果集ResultSet中的ResultSetMetaData getMetaData()方法，得到ResultSetMetaData的对象，
通过ResultSetMetaData接口中的方法可获得结果集的元数据：
(1) int getColumnCount()；获取结果集中的列数
(2) String getColumnLabel(int i)；获取表的列名，有别名，获取别名 ，无别名，获取列名
(3) String getColumnName(int i)；仅可获取表的列名，无法获取别名(使用较少)
注：i从1开始

代码演示6：对Customers表创建通用的查询方法

public class MyTest {
    /**
     * @param sql 要执行的sql语句
     * @param args sql语句中占位符?的值，有几个?写几个值，传递到可变个数形参中
     * @return 存放查询结果的List集合
     */
    public static List<Customers> Query(String sql, Object...args) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {
            connection = JDBCUtils.getConnection();
            preparedStatement = connection.prepareStatement(sql);
            //通过循环给?赋值
            for (int i = 0; i < args.length; i++) {
                preparedStatement.setObject(i + 1, args[i]);
            }
            //执行sql语句
            resultSet = preparedStatement.executeQuery();
            /*不同的sql语句得到的结果集不同，需要获得结果集的列数和名字，
              通过结果集的列数和名字，可以得知Order类中的哪些属性要被赋值 */
            //获取结果集的元数据
            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();
            //定义List集合
            List<Customers> list = new ArrayList<>();
            //开始遍历结果集并将结果放在List集合中
            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();
            //定义List集合
            List<Customers> list = new ArrayList<>();
            //开始遍历结果集并将结果放在List集合中
            while (resultSet.next()) {
                //在while中判断为真才创建对象，若结果集无数据但创建了对象，造成空间浪费
                Customers customers = new Customers();
                for (int i = 0; i < columnCount; i++) {
                    //获取所在行的指定列的值，通过反射，将此值存入对应的属性
                    Object columnValue = resultSet.getObject(i + 1);
                    /*获取所在行的指定列的名称(属性名)，由于属性名与列名不同，
                      故通过给列起别名使用getColumnLabel */
                    String columnLabel = metaData.getColumnLabel(i + 1);
                    //由于未知给哪个属性赋值，故通过反射将columnValue赋值给对应的属性
                    Field field = Customers.class.getDeclaredField(columnLabel);
                    field.setAccessible(true);
                    field.set(customers, columnValue);
                }
                list.add(customers);
            }
            return list;
        } catch (Exception throwables) {
            throwables.printStackTrace();
        } finally {
            JDBCUtils.close(resultSet, preparedStatement, connection);
        }
        return null;
    }
    //测试
    public static void main(String[] args) {
        String sql = "select email as EMAIL from customers where id = ? or id = ?";
        List<Customers> list = Query(sql,3,5);
        System.out.println(list);
    }
}

代码演示7：对不同表创建通用的查询方法
public class MyTest {
    public static <T> List<T> Query(Class<T> clazz, String sql, Object...args) {
        try {
            Connection connection = JDBCUtils.getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            for (int i = 0; i < args.length; i++) {
                preparedStatement.setObject(i + 1, args[i]);
            }
            ResultSet resultSet = preparedStatement.executeQuery();
            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();
            List<T> list = new ArrayList<>();
            while (resultSet.next()) {
                T t = clazz.newInstance();
                for (int i = 0; i < columnCount; i++) {
                    Object columnValue = resultSet.getObject(i + 1);
                    String columnName = metaData.getColumnLabel(i + 1);
                    Field field = clazz.getDeclaredField(columnName);
                    field.setAccessible(true);
                    field.set(t, columnValue);
                }
                list.add(t);
            }
            return list;
        } catch (Exception throwables) {
            throwables.printStackTrace();
        }
        return null;
    }   
    //测试
    public static void main(String[] args) {
        String sql =
                "select id as ID,name as NAME from customers where id = ? or id = ?";
        List<Customers> list = Query(Customers.class, sql, 3,4);
        System.out.println(list);

        String sql2 =
                "select order_name,order_date from order where order_id = ?";
        List<Order> list2 = Query(Order.class, sql2, 2);
        System.out.println(list2);
    }
}

PreparedStatement的好处：(以后均使用此接口，弃用Statement)

解决sql的注入问题
可以操作Blob的数据(二进制的大型数据)
void setBlob(int parameterIndex, InputStream inputStream)；
可以实现更高效的批量操作

六、操作Blob数据及进行批量操作
